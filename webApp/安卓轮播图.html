<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<link rel="shortcut icon" href="#">
	<meta name="apple-mobile-web-app-status-bar-style" content="black">
	<meta name="viewport" id="viewport" content="width=device-width,height=device-height,user-scalable=no,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,target-densitydpi=device-dpi" /> 
	<meta content="telephone=no" name="format-detection" />
	<title>安卓划屏</title>
	<link rel="stylesheet" type="text/css" href="css/Reset.css">
	<script>document.getElementsByTagName('html')[0].style.fontSize=100*window.innerWidth/1080+'px';</script>
<style>
#picWrap{height:6rem;position:relative;}
#picList{overflow: hidden;width:40.4rem;}
#picWrap a{float:left;width:10.8rem;}
#picWrap a img{width:10.8rem;height:6rem;}
#roundSpan{width:6rem;position:absolute;bottom:0;right:0;}
#roundSpan span{width:.5rem;height:.5rem;border-radius:.5rem;background:orange;float:left;margin-left:.3rem;}
#roundSpan span.active{background:red;} 
#roundSpan{width:6rem;position:absolute;bottom:0;right:0;}
#roundSpan span{width:.5rem;height:.5rem;border-radius:.5rem;background:orange;float:left;margin-left:.3rem;}
#roundSpan span.active{background:red;}
</style>
	<script>
window.onload=function(){
function defaultEvent(e){e.preventDefault();}
//touches当前位于屏幕上的所有屏幕上的一个
//targetTouches位于当前dom元素上的手指列表
//前两种,无法监控到touchend事件,当手指离开时,就会失去监控............
//changedTouches涉及当前事件的手指的一个列表
var picList=document.getElementById('picList');
var picListA=picList.getElementsByTagName('a');
var picListASingWidth=picListA[0].offsetWidth;
var roundSpan=document.getElementById('roundSpan');
var roundSpanBtn=roundSpan.getElementsByTagName('span');

//移动端滑动时,所滑动的元素不建议用position:absolate,用css3内的-webkit-transform:translate().做平移,因为这样的性能会比position:absolute更好.
var finalTranslateX=0;//最终要到达的平移量
var roundNow=0;//当前圆点标识
var startTranslateX=0;//手指放上去时的偏移量,跟用绝对定位做时的offsetLeft类似
var fingerStartX=0;//手指放上去的初始位置
var pptTimer=null;
picList.innerHTML+=picList.innerHTML;//以做无缝切换

picList.style.width=(picList.clientWidth)*2+'px';
function autoPptPlayer(){
	pptTimer=setInterval(function(){
		roundNow++;
		nextPpt();
	},2000);
}
autoPptPlayer();

picList.addEventListener('touchstart',touchStartFunc,false);
	
function touchStartFunc(e){
	clearInterval(pptTimer);//清除整体播放定时器
	clearInterval(picList.timer);//清除运动时定时器
	if(roundNow<=0){
		roundNow+=roundSpanBtn.length;
		finalTranslateX=-roundNow*window.screen.width;
		css(picList,"translateX",finalTranslateX);
	}

	fingerStartX=e.changedTouches[0].pageX;//手指刚开始触碰时,距离页面左边的距离
	startTranslateX=finalTranslateX;
}


picList.addEventListener('touchmove',touchMoveFunc,false);

function touchMoveFunc(e){
	document.addEventListener('touchmove', defaultEvent, false);//阻止默认事件
	var disX=e.changedTouches[0].pageX-fingerStartX;//移动过程中与开始位置的差值
	finalTranslateX=startTranslateX+disX;
	css(picList,"translateX",finalTranslateX);
};

picList.addEventListener('touchend',touchendFunc, false);

function touchendFunc(e){
	document.removeEventListener('touchmove',defaultEvent,false);//移除事件监听
	var disX=e.changedTouches[0].pageX-fingerStartX;//移动过程中与开始位置的差值
	var iNowNumber=Math.round(disX/window.screen.width);//四舍五入判断
	roundNow-=iNowNumber;
	//finalTranslateX=startTranslateX+disX;
	//roundNow=-finalTranslateX/window.screen.width;//平移量和屏幕的比列,下面一句话是如果移动距离超过了屏幕的多少时,就会做怎样的处理
	//roundNow=roundNow%1<0.3?Math.floor(roundNow):Math.ceil(roundNow);超过三分之一判断
	nextPpt();
	autoPptPlayer();
			}
function nextPpt(){
				finalTranslateX=-roundNow*window.screen.width;
				//选项卡切换
				for(var i=0;i<roundSpanBtn.length;i++){
					roundSpanBtn[i].className='';
				}
					roundSpanBtn[roundNow%roundSpanBtn.length].className='active';
			//css(obj,cssAttr,唯留值[最后唯一的值]);
			//css(picList,"translateX",finalTranslateX);有动画，所以用tweenMove();
					if(roundNow>=roundSpanBtn.length){//已经拉过第一轮出去第二轮了,用回调函数重置
					tweenMove(picList,{translateX:finalTranslateX},300,'easeOut',function(){
					roundNow%=roundSpanBtn.length;
					finalTranslateX=-roundNow*window.screen.width;
					css(picList,"translateX",finalTranslateX);
						});
					}else{
					tweenMove(picList,{translateX:finalTranslateX},300,'easeOut');
				}
			}

		












		}
//css3 tween运动微型框架
var tween = {
	easeOut: function(t, b, c, d){
		return -c *(t/=d)*(t-2) + b;
	},    
	backOut: function(t, b, c, d, s){
		if (typeof s == 'undefined') {
			s = 3.70158;  //回缩的距离
		}
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	}
};
function tweenMove(obj,oTarget,iTime,iType,fnEnd,fnDuring)
{
	var fn=tween[iType];
	var t=0;
	var b={};
	var c={};
	var d=iTime/24;
	var sAttr="";
	clearInterval(obj.timer);
	for(sAttr in oTarget)
	{
		b[sAttr]=css(obj,sAttr);
		c[sAttr]=oTarget[sAttr]-b[sAttr];
	}
	if(iTime<30)
	{
		for(sAttr in oTarget)
		{
			css(obj,sAttr,oTarget[sAttr]);
		}
	}
	else
	{
		obj.timer=setInterval(
		function()
		{
			if(t<d)
			{
				t++;
				for(sAttr in oTarget)
				{
					css(obj,sAttr,fn(t,b[sAttr],c[sAttr],d));
				}
			}
			else
			{
				for(sAttr in oTarget)
				{
					css(obj,sAttr,oTarget[sAttr]);
				}
				clearInterval(obj.timer);
				if(fnEnd)
				{
					fnEnd.call(obj);
				}
			}
			if(fnDuring)
			{
				fnDuring.call(obj);
			}
		},24);
	}
}
function css(obj, attr, value){
	if(arguments.length==2){
		if(attr=='scale'|| attr=='rotate'|| attr=='rotateX'||attr=='rotateY'||attr=='scaleX'||attr=='scaleY'||attr=='translateY'||attr=='translateX')
		{
			if(! obj.$Transform)
			{
				obj.$Transform={};
			}
			switch(attr)
			{
				case 'scale':
				case 'scaleX':
				case 'scaleY':
				return typeof(obj.$Transform[attr])=='number'?obj.$Transform[attr]:100;
				break;
				default:
					return obj.$Transform[attr]?obj.$Transform[attr]:0;
			}
		}
		var sCur=obj.currentStyle?obj.currentStyle[attr]:document.defaultView.getComputedStyle(obj, false)[attr];
		if(attr=='opacity'){
			return Math.round((parseFloat(sCur)*100));
		}
		else{
			return parseInt(sCur);
		}
	}
	else if(arguments.length==3)
	{
		switch(attr){
			case 'scale':
			case 'scaleX':
			case 'scaleY':
			case 'rotate':
			case 'rotateX':
			case 'rotateY':
			case 'translateZ':
			case 'translateX':
			case 'translateY':
			setCss3(obj, attr, value);
			break;
			case 'width':
			case 'height':
			case 'paddingLeft':
			case 'paddingTop':
			case 'paddingRight':
			case 'paddingBottom':
				value=Math.max(value,0);
			case 'left':
			case 'top':
			case 'marginLeft':
			case 'marginTop':
			case 'marginRight':
			case 'marginBottom':
				if(typeof value=="string")
				{
					obj.style[attr]=value;
				}
				else
				{
					obj.style[attr]=value+'px';
				}
				break;
			case 'opacity':
				obj.style.filter="alpha(opacity:"+value+")";
				obj.style.opacity=value/100;
				break;
			default:
				obj.style[attr]=value;
		}
	}
	return function (attr_in, value_in){css(obj, attr_in, value_in)};
}
function setCss3(obj, attr, value)
{
	var sTr="";
	var sVal="";
	var arr=["Webkit","Moz","O","ms",""];
	if(! obj["$Transform"])
	{
		obj["$Transform"]={};
	}
	obj["$Transform"][attr]=parseInt(value);
	for( sTr in obj["$Transform"])
	{
		switch(sTr)
		{
			case 'scale':
			case 'scaleX':
			case 'scaleY':
			sVal+=sTr+"("+(obj["$Transform"][sTr]/100)+") ";	
			break;
			case 'rotate':
			case 'rotateX':
			case 'rotateY':
			sVal+=sTr+"("+(obj["$Transform"][sTr])+"deg) ";	
			break;
			case 'translateX':
			case 'translateY':
			case 'translateZ':
			sVal+=sTr+"("+(obj["$Transform"][sTr])+"px) ";	
			break;
		}
	}
	for(var i=0;i<arr.length;i++)
	{
		obj.style[arr[i]+"Transform"]=sVal;
	}	
}	

	</script>
</head>
<body>
<script>
</script>
<section id="picWrap">
	<nav id="picList">
		<a href="javascript:void(0);"><img src="images/android1.jpg" alt=""></a>
		<a href="javascript:void(0);"><img src="images/android2.jpg" alt=""></a>
		<a href="javascript:void(0);"><img src="images/android3.jpg" alt=""></a>
		<a href="javascript:void(0);"><img src="images/android4.jpg" alt=""></a>
	</nav>
	<div id="roundSpan">
		<span class="active"></span>
		<span></span>
		<span></span>
		<span></span>
	</div>
</section>
</body>
</html>





